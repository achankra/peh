# OPA Gatekeeper Policy: Require Resource Limits
# This policy ensures all containers define CPU and memory requests/limits
# Prevents resource exhaustion and enables cluster autoscaling

---
# ConstraintTemplate defines the policy logic in Rego
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequireresourcelimits
  annotations:
    description: "Requires all containers to define resource requests and limits"
    examples: |
      Valid example:
      containers:
      - name: app
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"

      Invalid example:
      containers:
      - name: app
        # Missing resources specification

spec:
  # CRD generation - creates the Constraint CRD automatically
  crd:
    spec:
      names:
        kind: K8sRequireResourceLimits
      validation:
        openAPIV3Schema:
          type: object
          properties:
            excludedContainers:
              type: array
              items:
                type: string
              description: "Container names to exclude from this policy"

  # Rego policy logic
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequireresourcelimits

        # Deny rule for containers without resource limits
        violation[{"msg": msg}] {
          container := input_containers[_]
          not is_excluded(container.name)
          not has_resource_limits(container)
          msg := sprintf(
            "Container '%v' must define CPU and memory requests/limits",
            [container.name]
          )
        }

        # Helper: check if container is excluded
        is_excluded(name) {
          excluded := input.parameters.excludedContainers[_]
          name == excluded
        }

        # Helper: check if container has resource limits
        has_resource_limits(container) {
          container.resources.requests.cpu
          container.resources.requests.memory
          container.resources.limits.cpu
          container.resources.limits.memory
        }

        # Get all containers from pod spec
        input_containers[c] {
          c := input.review.object.spec.containers[_]
        }

        # Also check init containers
        input_containers[c] {
          c := input.review.object.spec.initContainers[_]
        }
